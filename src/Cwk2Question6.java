import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.Arrays;

public class Cwk2Question6 {
	Complex[] t, p;

	private boolean readInput() {
		BufferedReader r;
		String text, pattern;
		try {
			r = new BufferedReader(new FileReader("input.txt"));
			text = r.readLine();
			pattern = r.readLine();
			r.close();
		} catch (FileNotFoundException e) {
			System.err.println("Input file not found.");
			return false;
		} catch (IOException e) {
			System.err.println("Error reading input file.");
			return false;
		}
		if (text != null && pattern != null) {
			t = new Complex[text.length()];
			p = new Complex[pattern.length()];
			for (int i = 0; i < t.length; i++) {
				try {
					if (text.charAt(i) == '?') {
						t[i] = new Complex(0, 0);
					} else {
						t[i] = new Complex((int) (text.charAt(i)), 0);
					}
				} catch (Exception e) {
					System.err
							.println("Error parsing text string in input file.");
					return false;
				}
			}
			for (int i = 0; i < p.length; i++) {
				try {
					if (pattern.charAt(i) == '?') {
						p[i] = new Complex(0, 0);
					} else {
						p[i] = new Complex((int) (pattern.charAt(i)), 0);
					}
				} catch (Exception e) {
					System.err
							.println("Error parsing pattern string in input file.");
					return false;
				}
			}
		} else {
			System.err.println("Error reading input file: is the file empty?");
			return false;
		}
		return true;
	}

	private Complex[] doFFT(Complex[] A, int n) {
		if (n == 1) {
			return A;
		} else {
			// complex roots
			Complex w0 = new Complex(1, 0);
			Complex wk = new Complex(Math.cos((2 * Math.PI) / n),
					Math.sin((2 * Math.PI) / n));

			// sub arrays
			Complex[] A0 = new Complex[n / 2];
			Complex[] A1 = new Complex[n / 2];
			// put even indexed elements in A0, odds in A2
			for (int i = 0; i < n / 2; i++) {
				A0[i] = A[2 * i];
				A1[i] = A[2 * i + 1];
			}

			// evaluate at the complex roots
			Complex[] y0 = doFFT(A0, n / 2);
			Complex[] y1 = doFFT(A1, n / 2);
			Complex[] y = new Complex[A.length];
			for (int k = 0; k < n / 2; k++) {
				y[k] = y0[k].plus(w0.times(y1[k]));
				y[k + n / 2] = y0[k].minus(w0.times(y1[k]));
				w0 = w0.times(wk);
			}
			return y;
		}
	}

	private Complex[] inverseFFT(Complex[] A, int n) {
		Complex[] conj = new Complex[A.length];
		// conjugate all elements
		for (int i = 0; i < A.length; i++) {
			conj[i] = A[i].conjugate();
		}
		// perform fft on conjugated elements
		conj = doFFT(conj, conj.length);
		// conjugate back and divide by magnitude
		for (int i = 0; i < A.length; i++) {
			conj[i] = conj[i].conjugate();
			conj[i] = conj[i].times(new Complex(1.0 / (float) (n), 0));
		}
		return conj;
	}

	// allow for pattern of power of 2.
	/*
	 * strategy: add necessary padding to p, and add this same amount of padding
	 * to t
	 */
	// TODO: works for wildcards but broke others :(
	private int match() {
		// holds current substring from the text to compare to pattern
		Complex[] ts;
		// calculate the new pattern length thats a power of 2
		int len = p.length;
		if ((len & (len - 1)) != 0) {
			len--;
			len |= len >> 1;
			len |= len >> 2;
			len |= len >> 4;
			len |= len >> 8;
			len |= len >> 16;
			len++;
		}
		int dif = len - p.length;
		// loop through each index to compare the pattern
		for (int i = 0; i <= t.length - p.length; i++) {
			ts = Arrays.copyOfRange(t, i, i + len); // text substring
			// overwrite the parts corresponding to the padded zeroes
			// in the pattern
			for (int j = 1; j <= dif; j++) {
				ts[len - j] = new Complex(0, 0);
			}

			// create the arrays to store the point value
			// representation generated by fft
			Complex[] ts_pv = new Complex[2 * len];
			Complex[] p_pv = new Complex[2 * len];
			for (int j = 0; j < p_pv.length; j++) {
				if (j < p_pv.length / 2) {
					// pad with zeroes to the power of 2 length
					if (j >= p.length) {
						ts_pv[j] = new Complex(0, 0);
						p_pv[j] = new Complex(0, 0);
					} else { // otherwise copy in the vals
						// if this char is a wildcard for either the pattern
						// or the text, then set to 0 in both strings
						if (ts[j].getReal() == 0 || p[j].getReal() == 0) {
							ts_pv[j] = new Complex(0, 0);
							p_pv[j] = new Complex(0, 0);
						} else {
							ts_pv[j] = ts[j];
							p_pv[j] = p[j];
						}
					}
				} else { // pad the empty second half with zeroes
					ts_pv[j] = new Complex(0, 0);
					p_pv[j] = new Complex(0, 0);
				}
			}
			//System.out.println("in t:  " + Arrays.toString(ts_pv));
			//System.out.println("in p:  " + Arrays.toString(p_pv));
			ts_pv = doFFT(ts_pv, ts_pv.length);
			p_pv = doFFT(p_pv, p_pv.length);
			//System.out.println("fft:  " + Arrays.toString(p_pv));
			//System.out.println("fft:  " + Arrays.toString(ts_pv));
			for (int j = 0; j < p_pv.length; j++) {
				/*
				 * Sum(pt(p-t)^2) = Sum(p^3t-2p^2t^2+pt^3) ... = 0 if there's a
				 * match
				 */
				p_pv[j] = p_pv[j]
						.times(p_pv[j])
						.times(p_pv[j])
						.times(ts_pv[j])
						.minus(p_pv[j].times(p_pv[j]).times(ts_pv[j])
								.times(ts_pv[j]).times(new Complex(2, 0)))
						.plus(p_pv[j].times(ts_pv[j].times(ts_pv[j]).times(
								ts_pv[j])));
			}
			//System.out.println("vals: " + Arrays.toString(p_pv));
			p_pv = inverseFFT(p_pv, p_pv.length);
			//System.out.println("out:  " + Arrays.toString(p_pv));

			// check whether all elements = 0
			int r = 0;
			for (Complex c : p_pv) {
				//System.out.println("c = " + c.round(3).getReal());
				if (c.round(3).getReal() == 0) {
					r++;
				} else {
					continue;
				}
			}
			// if so, there's a match
			if (r == p_pv.length) {
				// System.out.println("match at: " + (i + 1));
				return i + 1;
			}
		}
		return -1;
	}

	private void run() {
		if (readInput() == true) {

			/*
			 * for (Complex c : t) { System.out.print(c.getReal() + " "); }
			 * System.out.println(); for (Complex c : p) {
			 * System.out.print(c.getReal() + " "); } System.out.println();
			 */
			System.out.println(match());
		}
	}

	public static void main(String[] args) {
		Cwk2Question6 match = new Cwk2Question6();
		match.run();
	}
}
